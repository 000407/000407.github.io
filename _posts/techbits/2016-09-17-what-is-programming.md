---
layout: post
title:  "Programming?"
date:   2016-09-17 15:42:18 +0530
categories: techbits
excerpt: This post intends to generalize and simplify the idea of a program.
---

## What is a program?

In simple leman terms in computing, a program is simply a set of instructions fed into a processor of any computing device so that the device would behave accordingly. To elaborate, we simply put the instructions together in textual format using a particular set of keywords, operations, data structures and rules to apply the aforesaid three elements, which is called “programming”.

The keywords, their syntax rules and operations together makes a programming language. For a simple example, java has keywords such as `public`, `class`, `if` and so forth, some rules you should abide by when you use those keywords together and certain operations such as `+`, `-`, `++` and so forth.

A program may not essentially be a combination of such text file which is undestood and executed by a computational device. Sometimes it may be a Finite State Machine, a machine that keeps on switching between a ___known number of states___ (hence the name finite state) as well. A finite state machine is a hardware combination that works in a known and predictable manner. In other words we simply put on nuts, bolts, rods, shafts, cogs and chains and all together so that it would achieve some task that we need. These are known to be ___hard-wired___ whereas the others which works according to a sequence of electronic signals is known as “micro-controlled”.

## History

According to most of the IT practitioners, history of programming begins in the 18th century where [Charles Babbage](https://en.wikipedia.org/wiki/Charles_Babbage) made the first ever computer, the ___[differential engine](https://en.wikipedia.org/wiki/Difference_engine)___. He then made the base for the device named ___[analytical engine](https://en.wikipedia.org/wiki/Analytical_Engine)___, which was programmed by [Ada Lovelace](https://en.wikipedia.org/wiki/Analytical_Engine). But actually, the history of programming runs back up until late 2nd century BC which is estimated to be the period that ___[Antikythera Mechanism](https://en.wikipedia.org/wiki/Antikythera_mechanism)___ was created by ancient Greeks.

Before 60’s programming was treated as an art. It was pretty much of an artwork. In fact, it still is. However in 1966, Corrado Bohm & Giuseppe Jacoppini, have pitched a concept called ___[Structured Program Theory](https://en.wikipedia.org/wiki/Structured_program_theorem)___. In there, they have emphasized on the point that every program is in the core, nothing more than a combination of sequence, selection and repetition. This along with some other core concepts, have made the modern day programming. We pursue a variety of programming paradigms such as object-oriented programming, aspect-oriented programming, subject-oriented programming, meta programming, functional programming and so forth. Most of these are based on the core idea that every program is ultimately nothing more than sequence, selection & repetition.

## Points to remember

To become a better programmer it requires two core characteristics fundamentally. First and foremost you should realize the point that ___every program is nothing but combining sequence, selection and repetition___. To understand this further, let us consider a simple scenario like compiling a thesis for a submission. You begin with meeting your mentor to __pitch your idea__. Then the mentor will __evaluate the idea__ and that evaluation might end up in three alternatives namely __accept the topic as it is__, __accept the topic with alterations__ and __reject the topic__. Now it's a very clear fact that there's no way that these three would happen together. For a given topic only ___ONE___ out of all these could happen. If it is the case mentioned last the rejection, you simply have to start all over from the beginning.

First of all, it is an obvious fact that the supervisor cannot __evaluate__ without knowing the idea that the student has in his mind. This makes it very clear that __evaluate__ falls right ___after___ the __pitching of idea__. Such steps occur one after another are simply known as __sequences__.

Second, where the step __evaluate the idea__ could possibly end up is having three alternatives. What's next after evaluation? ends up in a question ___where to go?___. This is conditionally guarded by the constrain ___how good your idea is?___. Based on a ___condition___ we ___choose the path to proceed___. This is simply a selection.

Third, assume that the idea that has __pitched__ by the student is __rejected__ by the supervisor. Now, we have to begin from the very beginning. It indicates that as long as the idea is __rejected__, __pitching__ and then __evaluating__ would repeatedly happen. Since it happens __repeatedly__, it is called an __iteration__, or a __repetition__.

Having understood the core, the rest is all about creativity. Once you properly understand these three, the limit of what you can do literally becomes the creativity. If your creativity is sky high, the sky would be the limit of what you can do.

At the same time, it is quite important to understand the fact that there may be different solutions for the same problem. I.e. there could be different combinations of __sequence__, __selection__ and __repetitions__ governed by different conditions, which yields the same result. So, the person called software __engineer__, should worry about resolving the problem

 - within the least possible time
 - in the fastest possible manner
 - with the most optimum usage of available resource
 - up to the required extent
 - while satisfying some ‘other’ requirements.

This is your abstract game plan, if you ever need to become a software engineer. Learn it! Live it! And love it!