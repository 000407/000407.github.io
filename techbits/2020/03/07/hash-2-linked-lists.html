<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>#::2-Linked Lists | ~my territory~</title>
<meta name="generator" content="Jekyll v3.10.0">
<meta property="og:title" content="#::2-Linked Lists">
<meta property="og:locale" content="en_US">
<meta name="description" content="A linked list is a data structure that is nothing but a list of elements which are linearly interlinked with the use of references. This post intends to explain the concepts behind linked lists, along with how to implement one, using C#.">
<meta property="og:description" content="A linked list is a data structure that is nothing but a list of elements which are linearly interlinked with the use of references. This post intends to explain the concepts behind linked lists, along with how to implement one, using C#.">
<link rel="canonical" href="https://kanchana.senadheera.net/techbits/2020/03/07/hash-2-linked-lists.html">
<meta property="og:url" content="https://kanchana.senadheera.net/techbits/2020/03/07/hash-2-linked-lists.html">
<meta property="og:site_name" content="~my territory~">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2020-03-07T10:12:18+00:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="#::2-Linked Lists">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2020-03-07T10:12:18+00:00","datePublished":"2020-03-07T10:12:18+00:00","description":"A linked list is a data structure that is nothing but a list of elements which are linearly interlinked with the use of references. This post intends to explain the concepts behind linked lists, along with how to implement one, using C#.","headline":"#::2-Linked Lists","mainEntityOfPage":{"@type":"WebPage","@id":"https://kanchana.senadheera.net/techbits/2020/03/07/hash-2-linked-lists.html"},"url":"https://kanchana.senadheera.net/techbits/2020/03/07/hash-2-linked-lists.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css">
<link type="application/atom+xml" rel="alternate" href="https://kanchana.senadheera.net/feed.xml" title="~my territory~">
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.css">

  <script type="text/javascript" src="/assets/js/jquery-3.5.1.min.js"></script>
</head>
<body>
<header class="site-header">

  <div class="wrapper">
<h2><a class="site-title" rel="author" href="/">~my territory~</a></h2>
<nav class="main-nav site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger">
  <div class="nav-bar">
    <ul class="nav-menu">
    
      <li>
        
          <span class="main-item"><a href="/">Home</a></span>
        
        
      </li>
    
      <li>
        
          <span class="main-item"><a href="/about">About</a></span>
        
        
      </li>
    
      <li>
        
          <span class="main-item"><a href="/blog">Blog</a></span>
        
        
      </li>
    
      <li>
        
          <span class="main-item">Tools</span>
        
        
          
          <ul>

  <li>
    
      <span class="sub-item"><a href="/tools/singlishw">Singlish Writer</a></span>
    
    
  </li>

</ul>
        
      </li>
    
    </ul>
  </div>
</div>
      </nav>
</div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">#::2-Linked Lists</h1>
    <p class="post-meta"><time class="dt-published" datetime="2020-03-07T10:12:18+00:00" itemprop="datePublished">
        Mar 7, 2020
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Let us start this discussion with a simple analogy, that is a story about one of my friends, Alice.</p>

<p>Say I need to meet Charlie, who happens to be someone in possession with a book I need and who is not friends with me. Then, there is Bob, who happens to be friends with Charlie, has a book in his possession, and Bob also knows that he knows someone who is friends with him either have the book I am looking for or knows someone who does so. Finally, there is Alice, who is friends with me, has a book in her possession and also knows that someone who is friends with her either knows or has the book. I, the one who needs the book, also know that someone that I know either. In summary, each person has a book and also friends with at most two people. Clear eh?</p>

<div class="mermaid">
    graph LR;
        I[Me] -- knows --&gt; A[Alice]
        A[Alice] -- knows --&gt; B[Bob];
        B[Bob] -- knows --&gt; Charlie["Charlie (hasBook=true)"];
</div>

<p>Now, in order for me to get my hands on that book I need so badly, I can simply start by going to Alice and ask from her if she has the book. Given that she does not have the book I need and knows only Bob other than me, she could introduce me to Bob. I could do the same with Bob and get introduced to Charlie and find out that Charlie has what I am looking for.</p>

<p>This analogy very closely resembles a LinkedList. A linked list is a data structure that is nothing but a list of elements which are linearly interlinked with the use of references. Each item in the list has at least two (02) properties which are namely,</p>

<ul>
  <li>Data – The data that is held by the element (in the above example the book)</li>
  <li>Next – A memory reference to the next item in the list (in the above example, whereabouts of the other person)</li>
</ul>

<p>This analogy can be easily implemented in the memory of the computer. Let’s look at a simple implementation done in C#.</p>

<p>The first thing to elaborate here is the interface that forms the contract that a class has to abide by, in order to act as a linked list. This interface can provide, but not limited to the signatures for the following operations.</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">void addToTail(data)</code> – Item will be added at the end/tail of the list.</li>
  <li>
<code class="language-plaintext highlighter-rouge">ListNode removeFromTail()</code> – Remove the last item from the list.</li>
  <li>
<code class="language-plaintext highlighter-rouge">bool isEmpty()</code> – Check if the list has no elements.</li>
  <li>
<code class="language-plaintext highlighter-rouge">int find(data)</code> – Find the item in a list and return its position.</li>
</ul>

<p>We can define an interface for this, which looks like follows.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">interface</span> <span class="nc">ILinkedList</span> <span class="p">{</span>
    <span class="k">void</span> <span class="nf">addToTail</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">);</span>
    <span class="n">ListNode</span> <span class="nf">removeFromTail</span><span class="p">();</span>
    <span class="kt">bool</span> <span class="nf">IsEmpty</span><span class="p">();</span>
    <span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>You might have noticed that I have included something that takes the name ListNode here. That is a class that I use to encapsulate the data. Let’s take a quick peak on that first, in order to lessen the confusions.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ListNode</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Data</span> <span class="p">{</span>
        <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">public</span> <span class="n">ListNode</span> <span class="n">Next</span> <span class="p">{</span>
        <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">public</span> <span class="nf">ListNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">Data</span> <span class="p">=</span> <span class="n">data</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">Next</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Take note on the fact that this list node is capable of holding only integer for the time being. We can always extend that with the use of generics.</p>

<p>Now, we can move on to implementing the interface in a concrete class named LinkedList. That will take the shape of the following scaffold.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">LinkedList</span> <span class="p">:</span> <span class="n">ILinkedList</span> <span class="p">{</span>
    <span class="k">private</span> <span class="n">ListNode</span> <span class="n">head</span><span class="p">;</span>
    <span class="k">public</span> <span class="nf">LinkedList</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">head</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// Other method implementations</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We have the private property head in this implementation. That is the essential component that keeps track of the memory location that the list begins. We initialize it to null and as we add the first element, it will start to point to that instead. Now let’s look at each of the methods to see how they are in action.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">addToTail</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ListNode</span> <span class="n">node</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ListNode</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">head</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//head == null means the list is empty.</span>
        <span class="k">this</span><span class="p">.</span><span class="n">head</span> <span class="p">=</span> <span class="n">node</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span> <span class="c1">// List is not empty. Have to find the tail...</span>
        <span class="n">ListNode</span> <span class="n">tmp</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">head</span><span class="p">;</span> <span class="c1">// Use a temporary pointer...</span>
        <span class="k">while</span><span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">Next</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// ...to find the node that has it's next is null</span>
            <span class="n">tmp</span> <span class="p">=</span> <span class="n">tmp</span><span class="p">.</span><span class="n">Next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">tmp</span><span class="p">.</span><span class="n">Next</span> <span class="p">=</span> <span class="n">node</span><span class="p">;</span> <span class="c1">// Found it. Assign the node as the next of tmp</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here, it flows as follows.</p>

<ol>
  <li>Create a ListNode to encapsulate the data.</li>
  <li>If the current head of the list is null, that means the list has no nodes. So we can set the new node as the head of our list.</li>
  <li>Otherwise, we have to find the tail (the last node) of the list. Tail has a special property that makes it distinct from other nodes. That is, its Next is null.</li>
  <li>To find such, we use a variable tmp that initially refers to the current head of the list.</li>
  <li>Starting from that, we keep on switching the reference of tmp to tmp.Next until tmp refers to the list node that its Next is null. That’s the end/tail of the list.</li>
  <li>Append our new node there.</li>
</ol>

<p>Obviously, this method to add something of the tail is not so efficient. The reason is having to sequentially reach the end every time. Assume a list of 1 million items. Adding to the tail of that? Let’s refactor the code a bit. This time, we keep another pointer like Head, the Tail, that points to the end of the list always.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">LinkedList</span> <span class="p">:</span> <span class="n">ILinkedList</span> <span class="p">{</span>
    <span class="k">private</span> <span class="n">ListNode</span> <span class="n">head</span><span class="p">;</span>
    <span class="k">private</span> <span class="n">ListNode</span> <span class="n">tail</span><span class="p">;</span>
    <span class="k">public</span> <span class="nf">LinkedList</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">head</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">tail</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
</code></pre></div></div>

<p>Our new add method will look like follows.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">addToTail</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ListNode</span> <span class="n">node</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ListNode</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">head</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//head == null means the list is empty.</span>
        <span class="k">this</span><span class="p">.</span><span class="n">head</span> <span class="p">=</span> <span class="n">node</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">tail</span> <span class="p">=</span> <span class="n">node</span><span class="p">;</span> <span class="c1">//tail will be the last element.</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span> <span class="c1">// List is not empty. Have to find the tail, which we already know.</span>
        <span class="k">this</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">Next</span> <span class="p">=</span> <span class="n">node</span><span class="p">;</span> <span class="c1">// current tail's Next will be the newnode.</span>
        <span class="k">this</span><span class="p">.</span><span class="n">tail</span> <span class="p">=</span> <span class="n">node</span><span class="p">;</span> <span class="c1">// new tail will be the newly added node.</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here we do a little bit of trade-off of memory, to avoid time complexity. The memory trade-off is insignificant because it’s just a pointer of a few bytes of size. When the list is not empty,</p>

<ul>
  <li>The newly created node will be the next of the current tail.</li>
  <li>After that set, the new node will become the new tail of the list.</li>
</ul>

<p>Next up, is the RemoveFromTail method. The implementation is as follows.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="kt">int</span> <span class="nf">RemoveFromTail</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nf">IsEmpty</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// If the list is already empty...</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">InvalidOperationException</span><span class="p">(</span><span class="s">"List is empty."</span><span class="p">);</span> <span class="c1">// Throw exception</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">data</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">Data</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">Next</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Head is the only element availble. so..</span>
        <span class="k">this</span><span class="p">.</span><span class="n">head</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span> <span class="c1">// reset head and tail and...</span>
        <span class="k">this</span><span class="p">.</span><span class="n">tail</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">;</span> <span class="c1">// Return recently detached data element</span>
    <span class="p">}</span>
    <span class="n">ListNode</span> <span class="n">tmp</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>
    <span class="c1">// tmp should refer to the node before the tail</span>
    <span class="k">while</span><span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">Next</span><span class="p">.</span><span class="n">Next</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span> 
        <span class="n">tmp</span> <span class="p">=</span> <span class="n">tmp</span><span class="p">.</span><span class="n">Next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// Removal</span>
    <span class="n">data</span> <span class="p">=</span> <span class="n">tmp</span><span class="p">.</span><span class="n">Next</span><span class="p">.</span><span class="n">Data</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="n">tail</span> <span class="p">=</span> <span class="n">tmp</span><span class="p">;</span> <span class="c1">// New tail should be the one referred by tmp.</span>
    <span class="k">this</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">Next</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span> <span class="c1">// New tail's Next should be null</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">;</span> <span class="c1">// Return recently detached data element</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here, it has three cases to address which are,</p>

<ol>
  <li>the list is empty. When the list is empty, we will throw an InvalidOperationException.</li>
  <li>the list has only one element. Here, we extract the data, reset the pointers head and tail to their defaults and return data.</li>
  <li>otherwise. Here, we extract the data and set the new tail of the list to the one before the element that is the current tail. Notice the while loop that checks <code class="language-plaintext highlighter-rouge">tmp.Next.Next != null</code>.</li>
</ol>

<p>You can already see that we use the <code class="language-plaintext highlighter-rouge">IsEmpty()</code> method to check the emptiness of the list before we remove from the tail. That method has a very straightforward implementation which is as follows. All it does is checking if the current head of the list is null and returning bool to indicate the state.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="kt">bool</span> <span class="nf">IsEmpty</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="n">head</span> <span class="p">==</span> <span class="k">null</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Finally, we need to find if we have a given data element in the list. That can be implemented as follows.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="kt">int</span> <span class="nf">Find</span><span class="p">(</span><span class="kt">int</span> <span class="n">needle</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ListNode</span> <span class="n">tmp</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span> <span class="c1">// 0 based index of the node being checked.</span>
    <span class="c1">// tmp should refer to the node before the tail</span>
    <span class="k">while</span><span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">Next</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">++</span><span class="n">index</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">Data</span> <span class="p">==</span> <span class="n">needle</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Check if the needle is the current item's data..</span>
            <span class="k">return</span> <span class="n">index</span><span class="p">;</span> <span class="c1">// found it. Return it...</span>
        <span class="p">}</span>
        <span class="n">tmp</span> <span class="p">=</span> <span class="n">tmp</span><span class="p">.</span><span class="n">Next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The method is intended to look for a data item in the entire list return its index. If not found the index will be -1. Searching is nothing but a simple linear traversal.</p>

<p>That is it for the time being. Given that these are abstract data types (ADTs), you are free to decide the implementations according to your preference and the purpose intended. There are many different optimizations that could be done on this before it is production-ready. For now, this should be enough. The complete implementation that includes some test cases, added in this gist. That’s it folks. Until next time. Happy coding! :)</p>

  </div>
  <div style="text-align: center;">~END~</div>
<div id="disqus_thread"></div>
  <script>
    var disqus_config = function () {
      this.page.url = 'https://kanchana.senadheera.net/techbits/2020/03/07/hash-2-linked-lists.html';
      this.page.identifier = 'https://kanchana.senadheera.net/techbits/2020/03/07/hash-2-linked-lists.html';
    };

    (function() {
      var d = document, s = d.createElement('script');

      s.src = 'https://000407.disqus.com/embed.js';

      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
<a class="u-url" href="/techbits/2020/03/07/hash-2-linked-lists.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col mt-center">
        <div class="social-links">
<a name="social_links"></a>
<div id="social-media">
    
    
        
        
            <a href="mailto:kanchana@senadheera.net" title="Email" class="social-icon"><i class="fa fac-square fa-envelope"></i></a>
        
    
        
        
            <a href="https://www.linkedin.com/in/kanchana-senadheera" title="LinkedIn" class="social-icon"><i class="fa fac-square fa-linkedin"></i></a>
        
    
        
        
            <a href="https://github.com/000407" title="GitHub" class="social-icon"><i class="fa fac-square fa-github"></i></a>
        
    
        
        
            <a href="https://stackoverflow.com/users/3126973" title="" class="social-icon"><i class="fa fac-square fa-stack-overflow"></i></a>
        
    
</div>
</div>
        <p>© 2017 Kanchana Senadheera @ KaZE<sub>2</sub>. All rights reserved.</p>
      </div>
    </div>
  </div>

</footer>


  
    <script type="text/javascript" src="/assets/js/mermaid.min.js"></script>
  
</body>

</html>
